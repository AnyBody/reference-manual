Inside the AnyBody Modeling System
**************************************
In this section, we shall attempt to describe the the way AnyBody, or rather
the AnyScript™ kernel of it, works. We shall do this in very general terms, which
means that we are not going into detail about particular operations of
particular classes. We shall focus on general functionalities and
properties of a model when it is loaded into AnyBody.

In order to cover these
issues, we shall firstly consider the loading process, i.e., the
processes that take place from initiating the loading of a model file
until it is completely loaded. Afterward, we shall generally consider
runtime processes. Runtime processes are evoked by executing operations
(:ref:`AnyOperation` objects).

The Loading process
========================================
The loading process is described best by explaining the sequence of
procedure that take place. This is done in the list below.

Scanning
   During the scanning the files are loaded into the computer’s memory. This
   implies that ``#include``-statements are resolved and the so-called file tree
   is constructed. The preprocessor resolves all :ref:`#include
   <preprocessor.include>` statements and other code-macros related to the
   :doc:`preprocessor <preprocessor>`. The nature of the preprocessor is code
   sequence dependent in contrast to normal behaviour in AnyScript™ code.

Parsing
   The parser breaks the text input into pieces and during this stage the
   syntax is checked. Basic syntactical errors are
   reported during this stage. Furthermore, the parser establishes some
   basic relations between the model in memory and the AnyScript™ code, which are
   later used by the system to assist the user getting from the model
   (in memory) to the code.

Constructing model tree
   Having parsed the text input, the parser can construct the data
   structures for the objects declared in the code. It hereby constructs
   the basic model tree that you find available in the Model Tree View
   in AnyBody’s GUI application. However, this is not the final complete tree,
   as we shall see later. This stage also implies basic validation of
   the data structure and related error reporting if necessary.

..    The preprocessor extends the
..    capabilities of the construction step. Simple AnyScript™ expressions can be
..    evaluated already by the preprocessor in this stage and the results
..    can therefore function as input to the creation of the objects. It
..    could for instance be a filename that is resolved this early, so that
..    the file can be found and used during the construction of an file
..    object to import needed data to form the object’s members.

..    Alternatively this could not happen until the Configuration step far
..    later, after most model links are established and fixed beyond
..    further change. This early behavior allows such file object (and
..    their like) to behave almost like #include files, i.e., creating
..    objects with unlimitted access from the rest of the model. The
..    trade-of is that the variables evaluated this early can only have
..    limitted connection with other model parameters, since they are
..    evaluated before most things are identified properly in the model.

Linking identifiers
   During this stage, values and references are linked together
   according to the expressions in the code. This implies various checks
   of the validity of the expressions such as check for existence of all
   referred identifiers, cyclic referencing, type validation of
   references.

Evaluating constants
   Having linked and validated all expressions, the mathematical
   expressions for values that are constant throughout the execution of
   the model are evaluated. These values play a special role, because
   they are input to the subsequent configuration stage. During this
   evaluation, the expressions are also checked for dimensional
   compatibility and the like, and :ref:`AnyValue`\ s having undefined
   dimensionality or dimension sizes are automatically set to fit the
   expressions.

Configuration
   The configuration is a complex process, in which
   the objects prepare themselves for performing their functionality.
   This implies that certain objects, that collect and combine
   information from many classes/object, for instance studies (:ref:`AnyStudy`
   and derived), establish links to their dependencies and process their
   information. This procedure relies on relationships between objects
   (and their classes) and it is carried out in a well defined sequence.
   If nothing else is implied for a given class there is assumed a
   downwards relationship in the object tree, so that the configuration
   of an object (folder objects only) may depend on its members. This is
   however not sufficiently general and therefore special classes
   (derived from ``AnyConfigFolder`` are able to state their own
   dependencies and allow the configuration to treat them accordingly.
   This do for instance imply that basic mechanical objects are
   configured before the mechanical studies that use them.

   Notice that the configuration sequence is not visible for the user.
   Notice also that during the configuration, new objects can be created
   into the object tree by existing objects. This has the special
   significance that you may find objects in the object tree, which
   cannot be referred to by references and in mathematical expressions
   as these links are validated before the configuration step.

Evaluating model
   After the configuration, the model is more or less ready. This means that
   initial values of all non-\ :ref:`const <InsideAMS_EvalMoments>` AnyValues
   can be set. This is done during the "Evaluating Model" stage. Notice that this
   first evaluation, as for the constant values evaluated before the
   configuration, implies a mathematical check of the expressions including
   automatic definition of undefined dimensionalities and dimension sizes of
   vectors, matrices and higher order tensors supported by the AnyValue types.

Post loading process
   Finally a post process is carried out. This stage makes the final
   preparation of the output data structures in the studies (:ref:`AnyStudy`’s Output
   folder). This cannot take place before, because the
   studies must be configured and all mathematical relations must be
   ready before that output is well-defined. This has the important
   implication that you cannot make mathematical expressions that
   directly access data in the output data structures for the simple
   reason that expressions are validated before the output exist. There
   is an indirect workaround to this using the :ref:`AnyOutputFun`.

After the loading process as described above is completed successfully,
the model is ready for execution of the operations it contains. We shall
refer to this as runtime operations or processes. We shall consider this
briefly in Section :ref:`InsideAMS-runtimeprocesses` but firstly we
shall turn our attention towards understanding evaluation moments.

.. _InsideAMS_EvalMoments:

Understanding evaluations moments
=========================================

We have in the previous sections just mentioned that some variables are
evaluated before the configuration of the model and some after. This
divides the variables into constants and runtime variables. The value of
these variables can in principle be controlled in two ways, either by
objects using them, i.e., a system controlled value, or by expressions
that have been specified in the model, i.e., a (more) user controlled
value.

AnyBody has a dynamic evaluation scheme in which mathematical
expressions defined by in the script will be evaluated during runtime
processes. This is handled by assigning a so-called evaluation moment to
each variable. The evaluation moment specifies in principle when a user
controlled value will be evaluated and when system controlled values are
ready for use.

.. list-table:: List tables can have captions like this one.
    :header-rows: 1

    * - PreProcessVar
      - Preprocessor variable (constants) that are evaluated during the preprocessor stages, i.e.,
        before and during the objects of the model is constructed. These can only hold simple
        expressions with limitted dependence to other objects in the model. Also error handling forthis
        step of evaluation is simpler.
    * - Const
      - Constants that are evaluated before the configuration stage and they are therefore input to the configuration.
    * - ConfigVar
      - Configuration dependent variables that are evaluated right after the configuration stage. They are thereby also constants but they are a result of the configuration rather than input to it.
    * - RuntimeVar
      - Runtime variables may change value during operations on the model.

"Runtime variables" (or RuntimeVar) is a actually a common name for
several evaluation moments. These are not covered here in detail,
because they will be different depending on version and configuration of
the AnyBody system. It is so that a study class typically defines (or inherits)
certain evaluation moments that have to do with the specific steps in
the particular investigation of that study.

.. _InsideAMS-runtimeprocesses:

Runtime Processes
-----------------

Runtime processes are started by the user by executing operations
(:ref:`AnyOperation`-derived) from the AnyBody interface, be it the console or the GUI
application.

Operations are typically split into several steps that are
sequentially executed, such as the time steps of a simulation or
parameter variation steps of a parameter study. Both interfaces of
AnyBody allow you to do a complete execution of an operation as well as
stepwise execution. During stepwise execution you will be able to follow
the changes in the model for each step, whether as displayed image in
the Model View of the GUI application or as a value variation in dumbed
values of charts. Each step of an operation may involve one or more
:ref:`evaluations moments <InsideAMS_EvalMoments>` and after each "moment"
has occurred in the operation algorithm, the associated values are updated.

.. An example is the mechanical studies :ref:`AnyMechStudy`. The mechanical
.. study is based on :ref:`AnyTimeStudy`, which is the base class for all studies
.. related to time-varying analyses. In the :ref:`AnyTimeStudy`, an evaluation
.. moment identifies the change of time as well as the evaluation of output
.. values in the end of the analysis step. These two evaluation moments are
.. extended in the mechanical studies with evaluation moments the identify
.. the different steps in the kinematical analysis, such as position,
.. velocity and acceleration analysis, as well as a step for the kinetic
.. (force) analysis. Doing one step of for instance the
.. InverseDynamicAnalysis in the AnyMechStudy will automatically take your
.. model through these step and corresponding evaluation moments.

Runtime processes may be executed sequentially and occasionally also nested into
each other. :ref:`Design studies <AnyDesStudy>` execute other operations in
order to investigate the impact of design changes. An evaluation moment
identifying the change of a design parameter is introduced prior to the the
above mentioned steps in the :ref:`AnyTimeStudy` and :ref:`AnyMechStudy`, and a later moment
is introduced to identify the end of the analysis operations. In this way, the
design study can change design parameters and and their dependent values, then
execute the analysis operation (or a sequence of several operations) updating
all its evaluation moments, and finally extract and compute design
characteristic output (so-called *design measures*) based on the final
evaluation moment of the design study.

Using AnyBody from the console
==============================================

It is possible to use the AnyBody Modeling system without the graphical user interface. The
AnyBody Console application provides a text based interface to carry out basic operation loading
models running analysis and saving results etc.

.. figure:: ../_static/anybodycon.png

The console application is controlled with a set of macro commands. The macro commands can be typed
interactively in the console application or saved to file which the can be passed to the console
application with the ``-m`` option.

The complete list of macro commands and further help on the console application can be found by
running the console application with the ``--help`` option:

.. code-block:: sh

    anybodycon.exe --help


.. seealso:: The `webcast on using the anybody console application <https://www.anybodytech.com/downloads/documentation/#20161124>`__

.. seealso:: The `AnyPyTools python <https://anybody-research-group.github.io/anypytools-docs/>`__ libraray provides
            an easier way of working with the console applicaiton.


.. rst-class:: html-toggle

AnyBody argument parser (tl;dr)
---------------------------------

The AnyBody Argument Parser a text parser that handles arguments for the
AnyBody executables as well as for certain intern functions. The internal
functions are parsing arguments to commands in the AnyBody Macro Language,
arguments to Class Operations of AnyScript™ Objects, and arguments in in special
HTML-links the AnyBody GUI’s description views.

The actual arguments for the different case will not be covered here,
but this is how you find more information:

AnyBodyCon.exe:
   More details about the arguments for AnyBodyCon.exe can be obtained
   by executing the program with the help option, '-?'

.. code:: sh

  AnyBodyCon.exe -?

AnyBody.exe:
   Please refer to the following section in this document for more
   details.

Class Operations:
   Please refer to reference page for the given class in this document
   or to the Object Description for a given object.

The basic principle of argument parsing in the AnyBody Argument Parser is the
same as in many console programs, i.e., you can add arguments to the
program or operation name using a short or a long argument name version.
For instance, the macro file name can be parsed to the  Console in the
following three way

.. code:: sh

  AnyBodyCon.exe -m <anymcr-file>
  AnyBodyCon.exe /m <anymcr-file>
  AnyBodyCon.exe –macrofile=<anymcr-file>

The argument short name is 'm' and the lon name is 'macrofile'

A special issue regarding The AnyBody Argument Parser is double-quoting
strings. Many arguments are names, file and directory paths, etc. that
needs to enclosed in double-quotes, ``"``, in order to find spaces in the
string. The parser handles this and it treats the double-quotes as a
special characters (delimiters of argument values). This, however, is a
problem if you need to provide string arguments that must contain
double-quotes as characters. Working with single arguments for the
AnyBody executables or standard operations this is typically not an issue,
except when supplying strings values to  definition or the like (see the
small example below); but if you work with more advanced applications
such as executing Class Operations from macro script or executing any
kind of operation from HTML-links in the AnyBody description views, then you
will soon face this problem. In general, any application, where
arguments supplied to one AnyBody Argument Parser contain arguments that is
subsequently supplied to another argument parser, is a typical case of
this problem because arguments for the two (or more) levels of parser
becomes nested.

In order to by-pass the problem of nested double-quoting, the AnyBody Argument
Parser is equipped with an option where you can use so-called escaped double-quotes.
The syntax is like in C and C++, where the escape-character is the back-slash ``\``, i.e.,
the escaped double-quote is ``*\"`` and to make a back-slash itself type ``\\``. To enter the
special mode, your argument must be preceded by three dashes, i.e., ``---`` (single- and
double-dash is used already, as short and long argument indicators).

Here is an example of the 'load' macro command executed with a
definition of MY_DEF equal to 5

.. code:: sh

  load -def MY_DEF= ---"\"5\""

where the standard appearance of this would be

.. code:: sh

  load -def MY_DEF="5"

The difference between these two statements is that the former will lead
to MY_DEF being a string containing '5' as a single character, whereas
the latter lead to MY_DEF being an integer with value five.

Notice the escaped back-slash is particular important when dealing with
file paths as in the following example of the definition of a path: The
simple syntax for a path definition in a load command is

.. code:: sh

  load -p MY_PATH=C:\Temp\MyFolder

where the escaped method is need for a path containing spaces

.. code:: sh

  load -def MY_PATH = ---"C:\\Temp\\MyFolder"

.. AnyBody GUI: Program Arguments and HTML-based Descriptions
.. ===========================================================
.. The AnyBody GUI accepts a number of arguments as program arguments and for
.. special internal commands that can be executed from description views in
.. AnyBody GUI. Basically, the same arguments are available in both situations,
.. but not all are meaningful in both cases. The basic syntax is also the
.. same in both case, however for internal usage it must be embedded in
.. HTML.

.. Therefore, a supplementary language that can be beneficial in relation
.. to AnyScript™ model authoring is HTML. From version 5.1 of AnyBody, the AMS GUI
.. application features a number of text views that are based on real HTML,
.. whereas these same view was earlier based on an internal representation.
.. These views and their hyperlinks to the model elements are an important
.. tool for browsing the model. Some of these views contain user-defined
.. information, which can now be formatted using HTML and not only plain
.. text as before.

.. The user-defined content is for instance Documentation Comments,
.. mentioned earlier, that enter as part of the Object Descriptions
.. available for all objects in the model and accessible from the Model
.. Tree of AMS. Moreover, some special description objects contain such
.. user-defined text descriptions, for instance in relation to project and
.. work-flow definitions and documentation. These are both features that
.. aim at providing the ability to document your model in close relation to
.. the model, i.e., inside or very close to the code itself. With the
.. ability of using HTML formatting it is now easier to make more complete
.. documentation which is also more visually appealing and more readable.

.. In addition to the formatting options provided by HTML, a number of
.. special types of hyperlinks is available with which you can provide
.. links to elements of the model itself, including to some extend
.. executing operations of the model.

.. The basic syntax of such links is a standard HTML anchor in which we
.. refer to 'anybody' in the hyperlink URL:

.. .. code:: sh

..   <a href="about:anybody 'parameters'">Text of the link<a/>"

.. The 'parameters' that are available for the  GUI as both program
.. arguments and for internal HTML references are:

.. .. code:: sh

..   -ed <any-file:lineno>, –editor=<any-file:lineno>:

.. Opens the file in the editor.

.. .. code:: sh

..   -en <object-name>, –editorname=<object-name>:

.. Opens the construction-location of an object in the editor (Locate in
.. Script).

.. .. code:: sh

..   -ob <object-name>, –object=<object-name>:

.. Finds and shows the object in the Model Tree view..

.. .. code:: sh

..   -cl [<class-name>, –class=<class-name>:

.. Opens the AnyScript Reference Manual entry for the specified class.

.. .. code:: sh

..   -mc <macro-file \| macro-string \| macro-string-object-name>, –macro=<macro-file \| macro-string \| macro-string-object-name> \| <object-name>:

.. Executes a macro given as either a macro file, a string containing
.. the macro or the name of an AnyStringVar object containing the macro.
.. As program argument for AnyBody.exe only the former makes sense.

.. .. code:: sh

..   -xp <folderpath>, –os_explorer=<folderpath>:

.. Opens an Explorer at the specified location.

.. .. code:: sh

..   -ws <anyws-file>, –anyworkspace=<anyws-file>:

.. Opens a workspace file in the AnyBody Modeling System.

.. .. code:: sh

..   -ni, –noninteractive:

.. Specifies not to enter interactive mode after startup macro commands.
.. Active only together with "macro" argument and only as a program
.. argument for AnyBody.exe.

